mysql执行顺序：
(1)from (2)on (3)join (4)where (5)group by (6)having (7)select(8）order by(9)limit

mysql select * from t left join s on t.id=s.tid where s.id is null;
union 取两条sql的合集并去重
哪些情况不适合建索引
表记录比较少、更新频繁的、列大量重复数据、比如性别，只有男和女的不适合建索引

mysql执行计划
explain 
id相同，mysql从上至下执行
如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行
相同又不同，先执行序号大的，相同的再从上至下顺序执行


select_type primary 最外层查询 、subquery子查询 、simple(简单查询)、derived
（在from列表中包含的子查询被标记为derived）、union、union result

table derived2 =衍生，相当与id为的查询衍生的虚表

type
从最好到最差依次是：
system>const>eq_ref>ref>range>index>ALL
system只有一行记录
const 主键或唯一索引，通过索引一次就找到了，如将主键置于where
列表中，mysql就能将该查询转换为一个常量
eq_ref 唯一性索引扫描，对于每个索引建，表中只有一条记录与之匹配
常见于主键或唯一索引
ref非唯一性索引扫描，返回匹配某个单独值得所有行
range只检索给定范围的行，使用一个索引来选择行
index index与All区别为index类型只遍历索引树，因为索引文件相对比较小，索引比All快理论上

possible_keys 显示可能应用在这张表中的索引，一个或多个
key 实际用到的索引，如果为NULL，则没有使用索引；查询中若使用了覆盖索引，
则该索引仅出现在key列表中
rows每张表有多少行被优化器查询，根据表统计信息及索引选用情况，大致估算出
找到所需的记录所需要读取的行数
.ref显示索引的哪一列被使用了，如果可能的话，是一个常数，哪些列或者常量被用于查找索引列上的值。
只有当type为ref的时候，ref这列才会有值

Extra 
using filesort说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。mysql
中无法利用索引完成的排序操作称为“文件排序”(避免)
using temporary 使用了临时表保存中间结果，mysql在对查询结果排序时使用临时表。常见于排序order
 by 和分组group by（避免）
using index表示相应的select操作中使用了覆盖索引，避免了访问表的数据行， 如果同时出现using where
表明索引被用来执行索引键值得查找，如果没有同时出现using where 表明索引用来读取数据而非执行查找动作
using where 、using join buffer、impossible where、select tables optimized away、distinct

左连接在右表建立索引
尽可能减少join语句中的NestedLoop的循环总次数:"永远用小结果集驱动大的结果集"
优先优化NestedLoop的内层循环
保证join语句中被驱动表上join条件字段已经被索引
当无法保证被驱动表的Join条件字段被索引且内存资源充足的前提下，不要太吝啬joinbuffer的设置

（1）全值匹配我最爱
（2）最佳左前缀法则，如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列
（3）不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描
（4）mysql不能使用索引中范围条件右边的列（在一个索引列上使用了如>这种范围条件的会导致后边的索引列全部失效），范围之后全失效
 (5)尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select*
  (6)mysql在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描
  (7)is null，is not null也无法使用索引
  (8)like 以通配符开头（'%abc...'）mysql索引失效会变成全表扫描的操作，百分like加右边，则后面的列索引依然可以生效，非要两边都使用%,最好查询的列是覆盖索引
 (9)字符串不加单引号索引失效
 (10)少用or,用它来连接是会索引失效

where后常量索引顺序可以换，mysql可以优化
简单查询mysql 自身可以优化索引
对于单键索引，尽量选择针对当前query过滤性更好的索引
在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好
在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引
尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的

优化总结口诀：
全值匹配我最爱，最左前缀要遵守；
带头大哥不能死，中间兄弟不能断；
索引列上少计算，范围之后全失效；
LIKE百分写最右，覆盖索引不写星；
不等空值还有or,  索引失效要少用；
VAR引号不可丢，sql高级也不难。

select * from A where exists (select 1 from B where B.id=A.id)
当A表的数据集小于B表的数据集时，用exists优于in;反之用in  select * from A where id in (select id from B)
select .... from table where exists (subquery)
该语法可以理解为：将主查询的数据，放到子查询中做条件验证，根据验证结果（true或false）
来决定主查询的数据结果是否得以保留
并发事务带来的问题：
更新丢失：当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每个事务都不知道其他事务
的存在，就会发生丢失更相信问题--（最后的更新覆盖了由其他事务所做的更新），
如果一个程序员完成并提交事务之前，另一个程序员不能访问同一文件，则可避免此问题
脏读：事务A 读取到了事务B已修改但尚未提交的数据，还在这个数据基础上做了修改。此时，如果B事务回滚，
A读取的数据无效，不符合一致性要求
不可重复读：一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了
改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。一句话：事务A读取到了事务B已经提交的修改
数据，不符合隔离性
幻读：一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，
这种现象就称为“幻读”。
一句话：事务A读取到了事务B提交的新增数据，不符合隔离性。
幻读和脏读有点类似
脏读是事务B里面修改了数据，幻读事务B里面新增了数据

未提交读(脏、不可重复读、幻)、已提交读（不可重复读、幻读）、可重复读（幻读）、可序列化，mysql默认可重复读
查看数据库的事务隔离级别：show variables like "tx_isolation"

锁定一行：
begin:
update 语句 for update;  for update 人为上锁
commit;
